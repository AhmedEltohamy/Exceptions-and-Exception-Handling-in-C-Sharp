# Exceptions and Exception Handling in C#

The C# language's exception handling features help you deal with any unexpected or exceptional situations that occur when a program is running.

Exception handling uses the `try`, `catch`, and `finally` keywords to try actions that may not succeed, to handle failures when you decide that it's reasonable to do so, and to clean up resources afterward.

A `try` block requires one or more associated `catch` blocks, or a `finally` block, or both. <br>
A `try` block without a `catch` or `finally` block causes a compiler error.

Exceptions can be generated by the common language runtime (CLR), by .NET or third-party libraries, or by application code.

Exceptions are created by using the `throw` keyword.

In many cases, an exception may be thrown not by a method that your code has called directly, but by another method further down in the call stack. <br>
When an exception is thrown, the CLR will unwind the stack, looking for a method with a `catch` block for the specific exception type, and it will execute the first such `catch` block that it finds. If it finds no appropriate `catch` block anywhere in the call stack, it will **terminate the process** and display a message to the user.

Exceptions are represented by classes derived from `Exception` class. This class identifies the type of exception and contains properties that have details about the exception. Throwing an exception involves creating an instance of an exception-derived class, optionally configuring properties of the exception, and then throwing the object by using the throw keyword.

```
class CustomException : Exception
{
    public CustomException(string message)
    {
    }
}

private static void TestThrow()
{
    throw new CustomException("Custom exception in TestThrow()");
}
```

After an exception is thrown, the runtime checks the current statement to see whether it is within a `try` block. If it is, any `catch` blocks associated with the `try` block are checked to see whether they can catch the exception. `Catch` blocks typically specify exception types; if the type of the catch block is the same type as the exception, or a base class of the exception, the `catch` block can handle the method. For example:

```
try
{
    TestThrow();
}
catch (CustomException ex)
{
    System.Console.WriteLine(ex.ToString());
}
```

If the statement that throws an exception isn't within a `try` block or if the `try` block that encloses it has no matching `catch` block, the runtime checks the calling method for a `try` statement and `catch` blocks. The runtime continues up the calling stack, searching for a compatible `catch` block. After the `catch` block is found and executed, control is passed to the next statement after that `catch` block.

A `try` statement can contain more than one `catch` block. The first `catch` statement that can handle the exception is executed; any following `catch` statements, even if they're compatible, are ignored. Order `catch` blocks **from most specific (or most-derived) to least specific**. For example:

```
try
{
    using (var sw = new StreamWriter("./test.txt"))
    {
        sw.WriteLine("Hello");
    }
}
// Put the more specific exceptions first.
catch (DirectoryNotFoundException ex)
{
    Console.WriteLine(ex);
}
catch (FileNotFoundException ex)
{
    Console.WriteLine(ex);
}
// Put the least specific exception last.
catch (IOException ex)
{
    Console.WriteLine(ex);
}
Console.WriteLine("Done");
```

If no compatible catch block is found on the call stack after an exception is thrown, one of three things occurs: <br>
- If the exception is within a finalizer, the finalizer is aborted and the base finalizer, if any, is called.
- If the call stack contains a static constructor, or a static field initializer, a `TypeInitializationException` is thrown, with the original exception assigned to the `InnerException` property of the new exception.
- If the start of the thread is reached, the thread is terminated.

## Catch Blocks

A `catch` block can specify the type of exception to catch. The type specification is called an ***exception filter***. The exception type should be derived from `Exception`. In general, don't specify `Exception` as the exception filter unless either you know how to handle all exceptions that might be thrown in the try block, or you've included a `throw` statement at the end of your `catch` block.

Multiple `catch` blocks with different exception classes can be chained together. The `catch` blocks are evaluated from top to bottom in your code, but only one `catch` block is executed for each exception that is thrown. The first `catch` block that specifies the exact type or a base class of the thrown exception is executed. If no `catch` block specifies a matching exception class, a `catch` block that doesn't have any type is selected, if one is present in the statement. It's important to position `catch` blocks with the most specific (that is, the most derived) exception classes first.

#### Catch exceptions when the following conditions are true: <br>

- You have a good understanding of why the exception might be thrown, and you can implement a specific recovery, such as prompting the user to enter a new file name when you catch a `FileNotFoundException` object.

- You can create and throw a new, more specific exception.
    ```
    int GetInt(int[] array, int index)
    {
        try
        {
            return array[index];
        }
        catch (IndexOutOfRangeException e)
        {
            throw new ArgumentOutOfRangeException(
                "Parameter index is out of range.", e);
        }
    }
    ```
- You want to partially handle an exception before passing it on for more handling. In the following example, a `catch` block is used to add an entry to an error log before rethrowing the exception. 
    ```
    try
    {
        // Try to access a resource.
    }
    catch (UnauthorizedAccessException e)
    {
        // Call a custom error logging procedure.
        LogError(e);
        // Re-throw the error.
        throw;
    }
    ```
#### Exception Filters with Boolean Expression

You can also specify ***exception filters*** to add a ***boolean expression*** to a catch clause. Exception filters indicate that a specific catch clause matches only when that condition is true. In the following example, both catch clauses use the same exception class, but an extra condition is checked to create a different error message:

```
int GetInt(int[] array, int index)
{
    try
    {
        return array[index];
    }
    catch (IndexOutOfRangeException e) when (index < 0) 
    {
        throw new ArgumentOutOfRangeException(
            "Parameter index cannot be negative.", e);
    }
    catch (IndexOutOfRangeException e)
    {
        throw new ArgumentOutOfRangeException(
            "Parameter index cannot be greater than the array size.", e);
    }
}
```

An exception filter that always returns `false` can be used to examine all exceptions but not process them. A typical use is to log exceptions:
```
public static void Main()
{
    try
    {
        string? s = null;
        Console.WriteLine(s.Length);
    }
    catch (Exception e) when (LogException(e))
    {
    }
    Console.WriteLine("Exception must have been handled");
}

private static bool LogException(Exception e)
{
    Console.WriteLine($"\tIn the log routine. Caught {e.GetType()}");
    Console.WriteLine($"\tMessage: {e.Message}");
    return false;
}
```
The `LogException` method always returns `false`, no `catch` clause using this exception filter matches. The catch clause can be general, using `System.Exception`, and later clauses can process more specific exception classes.

## Finally Blocks

A `finally` block enables you to clean up actions that are performed in a `try` block. If present, the `finally` block executes last, after the `try` block and any matched `catch` block. A `finally` block always runs, whether an exception is thrown or a `catch` block matching the exception type is found.

the `finally` block is executed when control leaves the `try` block. Control might leave the `try` block as a result of:
- normal execution,
- execution of a **jump statement** (that is, `return`, `break`, `continue`, or `goto`), or
- propagation of an exception out of the `try` block.

The `finally` block can be used to release resources such as file streams, database connections, and graphics handles without waiting for the garbage collector in the runtime to finalize the objects.

In the following example, the `finally` block is used to close a file that is opened in the `try` block. Notice that the state of the file handle is checked before the file is closed. If the `try` block can't open the file, the file handle still has the value `null` and the `finally` block doesn't try to close it. Instead, if the file is opened successfully in the `try` block, the `finally` block closes the open file.
```
FileStream? file = null;
FileInfo fileinfo = new System.IO.FileInfo("./file.txt");
try
{
    file = fileinfo.OpenWrite();
    file.WriteByte(0xF);
}
finally
{
    // Check for null because OpenWrite might have failed.
    file?.Close();
}
```

## Creating and Throwing Exceptions

Exceptions are used to indicate that an error has occurred while running the program. Exception objects that describe an error are created and then thrown with the **`throw` statement or expression**. The runtime then searches for the most compatible exception handler.

#### Programmers should throw exceptions when one or more of the following conditions are true:

- The method can't complete its defined functionality. For example, if a parameter to a method has an invalid value:
    ```
    static void CopyObject(SampleClass original)
    {
        _ = original ?? throw new ArgumentException("Parameter cannot be null", nameof(original));
    }
    ```
- An inappropriate call to an object is made, based on the object state. One example might be trying to write to a read-only file. In cases where an object state doesn't allow an operation, throw an instance of `InvalidOperationException` or an object based on a derivation of this class. The following code is an example of a method that throws an `InvalidOperationException` object:
    ```
    public class ProgramLog
    {
        FileStream logFile = null!;
        public void OpenLog(FileInfo fileName, FileMode mode) { }

        public void WriteLog()
        {
            if (!logFile.CanWrite)
            {
                throw new InvalidOperationException("Log file cannot be read-only");
            }
            // Else write data to the log and return.
        }
    }
    ```
- When an argument to a method causes an exception. In this case, the original exception should be caught and an `ArgumentException` instance should be created. The original exception should be passed to the constructor of the `ArgumentException` as the `InnerException` parameter:
    ```
    static int GetValueFromArray(int[] array, int index)
    {
        try
        {
            return array[index];
        }
        catch (IndexOutOfRangeException e)
        {
            throw new ArgumentOutOfRangeException(
                "Parameter index is out of range.", e);
        }
    }
    ```

#### Note
- The example above is for illustrative purposes. Index validating via exceptions is in most cases bad practice. Exceptions should be reserved to guard against exceptional program conditions, not for argument checking as above.

Exceptions contain a property named `StackTrace`. This string contains the name of the methods on the current call stack, together with the file name and line number where the exception was thrown for each method. A `StackTrace` object is created automatically by the common language runtime (CLR) from the point of the `throw` statement, so that exceptions must be thrown from the point where the stack trace should begin.

All exceptions contain a property named `Message`. This string should be set to explain the reason for the exception. Information that is sensitive to security shouldn't be put in the message text.

Public and protected methods throw exceptions whenever they can't complete their intended functions. The exception class thrown is the most specific exception available that fits the error conditions. These exceptions should be documented as part of the class functionality, and derived classes or updates to the original class should retain the same behavior for backward compatibility.

## Things to Avoid When Throwing Exceptions

- Don't use exceptions to change the flow of a program as part of ordinary execution. Use exceptions to report and handle error conditions.
- Exceptions shouldn't be returned as a return value or parameter instead of being thrown.
- Don't throw `System.Exception`, `System.SystemException`, `System.NullReferenceException`, or `System.IndexOutOfRangeException` intentionally from your own source code.

## Defining Exception Classes

Programs can throw a predefined exception class in the `System` namespace (except where previously noted), or create their own exception classes by deriving from `Exception`. The derived classes should define at least three constructors: one parameterless constructor, one that sets the message property, and one that sets both the `Message` and `InnerException` properties. For example:
```
public class InvalidDepartmentException : Exception
{
    public InvalidDepartmentException() : base() { }
    public InvalidDepartmentException(string message) : base(message) { }
    public InvalidDepartmentException(string message, Exception inner) : base(message, inner) { }
}
```
Add new properties to the exception class when the data they provide is useful to resolving the exception. If new properties are added to the derived exception class, `ToString()` should be overridden to return the added information.

## Helpful Resources
- [Error Handling in C# 10 (pluralsight)](https://app.pluralsight.com/library/courses/error-handling-c-sharp-10/table-of-contents)
- [Exceptions and Errors (microsoft docs)](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions)
- [Exception Handling Statements (microsoft docs)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/statements/exception-handling-statements)
- [Exception Class (microsoft docs)](https://learn.microsoft.com/en-us/dotnet/api/system.exception)
- [Best practices for Exceptions (microsoft docs)](https://learn.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions)
- [.Net Exceptions Best Practices](https://hamidmosalla.com/2018/02/28/net-exception-best-practices/)
- [C# Exception Handling Best Practices](https://dzone.com/articles/c-exception-handling-best-practices)
- [Exceptions for flow control in C#](https://enterprisecraftsmanship.com/posts/exceptions-for-flow-control/)
- [Exception Handling In Asynchronous Code](https://hamidmosalla.com/2018/06/19/exception-handling-in-asynchronous-code/)
